# -*- coding: utf-8 -*-
"""Maya Lev Lehman Lab 4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vZek6hX0OWDq3k49LWK2ETqhwQPS-3pK

#Monte Carlo
"""

import numpy as np #for numerical operations
import matplotlib.pyplot as plt # to generate plots

#array x
x = np.linspace(-3,3,100) #x values are between -3 and 3

x

y = x**2 + 2 #use the x values in the array and plug it into y to create array y

y

plt.plot(x,y)

#finding area under the curve using the formula stated below

"""$f(x) = x^2 + 2$

$Area = \int_a^bf(x) dx$

$= \int_a^b (x^2+2) dx$

$= \left.\frac{x^3}{3}+2x\right\vert_1^2$

$= (\frac{8}{3}+4) - (\frac{1}{3}+2)$

$= \frac{13}{3}$
"""

13/3

"""To integrate the function $f(x)$ over the interval $[a,b]$ we

[1] find some value $M$ such that $f(x) < M$ over the interval $[a,b]$

[2] select a random number $x$ from a uniform distribution over the interval $[a,b]$

[3] select a random number y from a uniform distribution over the interval $[0,M]$

[4] determine if $y > f(x)$ or $y ≤ f(x)$

[5] repeat this process $N$ times, keeping track of the number of times $y ≤ f(x)$ or under the curve, successes $S$.

The estimated probability of success is then:

$\frac{S}{N}=\frac{\text{Area under curve}}{\text{Total area inside rectangle}} = \frac{\int_a^bf(x)dx}{M(b-a)}$

$\int_a^bf(x)dx = M(b-a)\frac{S}{N}$
"""

def f(x):
    y = x**2 + 2
    return y

f(x)

plt.plot(x,f(x))

###parameters for Monte Carlo simulation

M = 10 #max y value

a = 1 #lower bound
b = 2 #upper bound

x = a + (b-a)*np.random.random() #random x value within interval [a, b]

x

y = M*np.random.random() #random y value within the interval [0, M]

x,y,f(x)

y < f(x) #checking if our y value is under the curve

N = 100_000 #N random points to be sampled
S = 0 #counter for points under the curve

#Monte Carlo simulation loop
for i in range(N):

    x = a + (b-a)*np.random.random() #random x value
    y = M*np.random.random() #random y value

    S += (y < f(x)) #increment S if y is under the curve

M*(b-a)*(S/N) #estrimated area under the curve

x

y



def f(x):
    y = x**2 + 2
    return y

#Monte Carlo integration function
def monte_carlo_integrate(f,a,b,N):

    N = 100000 # N number of points to sample
    S = 0 #a counter for points under the curve
    for i in range(N):

        x = a + (b-a)*np.random.random() #range [a,b]
        y = M*np.random.random() #range [0,M]
#checking if the randomly chosen y value is less than f(x)
        S += (y < f(x)) #chance that we hit under the curve

    return M*(b-a)*(S/N) #estimated area under the curve

monte_carlo_integrate(f,1,2,1000)



from sympy import * #symbolic python for symbolic integration

x = Symbol('x') #the symbol x

x

integrate(x**2 + 2, (x,1,2)) #integrate x from 1 to 2 (in this example)

13/3

integrate(x**3 + 3, (x,1,2)) #integrate x from 1 to 2 (in this example)

27/4

x = 0

def f(x):
    y = x**3 + 3
    return y

monte_carlo_integrate(f,1,2,1000000) #run Monte Carlo integration for the function above: y = x^3 +3



#Simulation to visualize convergence for Monte Carlo integration
N = 2000 # N number of iterations
S = 0 #a counter for points under the curve
Z = np.zeros(N,) # Array Z to store estimated area after every iteration
for i in range(1,N): # estimated area afer each iteration

    x = a + (b-a)*np.random.random()
    y = M*np.random.random()

    S += (y < f(x)) #increment counter if point is under the curve

    Z[i] = M*(b-a)*(S/i) # Update estimated area in array Z

plt.plot(Z) #estimated area
plt.plot(6.75*np.ones(Z.shape)) #horizontal line of actual area under the curve(the actual area is 6.75) for the function integrated from 1 to 2



import numpy as np #for numerical operations
import matplotlib.pyplot as plt #to generate plots
from sympy import Symbol, integrate #symoblic math, enables exact integration

# Define a general function for Monte Carlo integration
def monte_carlo_integrate(func, a, b, N, M):
    S = 0 #counter for points under the curve
    for _ in range(N): # repeat N times
        x = a + (b - a) * np.random.random() #random x within interval [a,b]
        y = M * np.random.random() #random y within range [0,M]
        if y < func(x): #checking if it is under the curve
            S += 1 #increase the counter if the point is under the curve
    return M * (b - a) * (S / N) #estimated area under the curve

# Define the functions to be integrated
def f1(x):
    return x**2 + 2

def f2(x):
    return x**3 + 3

# Calculate exact and estimated areas
def calculate_areas(func, a, b, N, M):
    x_sym = Symbol('x')
    exact_area = integrate(func(x_sym), (x_sym, a, b)).evalf()
    estimated_area = monte_carlo_integrate(func, a, b, N, M) #estimated area using Monte Carlo integration
    return exact_area, estimated_area

# Plotting function
def plot_function(func, title, a=-3, b=3):
    x = np.linspace(a, b, 100) #100 points between a and b
    y = func(x) #evaluate function at each x value
    plt.plot(x, y, label=title)
    plt.title(title)
    plt.xlabel("x")
    plt.ylabel("f(x)")
    plt.legend()
    plt.show()

# Plot the functions
plot_function(f1, "$f(x) = x^2 + 2$")
plot_function(f2, "$f(x) = x^3 + 3$")

# Calculate and print areas (exact estimated area)
exact_area_f1, estimated_area_f1 = calculate_areas(f1, 1, 2, 100000, 20)
exact_area_f2, estimated_area_f2 = calculate_areas(f2, 1, 2, 1000000, 20)

print("Exact Area under f1:", exact_area_f1)
print("Estimated Area under f1:", estimated_area_f1)
print("Exact Area under f2:", exact_area_f2)
print("Estimated Area under f2:", estimated_area_f2)





"""# Visualization"""

import numpy #for numerical operations
import matplotlib.pyplot as plt # to generate plots

# Function to plot points for Monte Carlo integration
def plot_monte_carlo(func, a, b, M, N):
    x_points = a + (b - a) * np.random.random(N) #to generate N random x points in the interval [a,b]
    y_points = M * np.random.random(N) #to generate N random y points in the range [0,M]
    below = y_points < func(x_points) #which points are below the curve
    above = np.invert(below) #which points are above the curve

    # Plotting the function
    x = np.linspace(a - 1, b + 1, 400)
    y = func(x)
    plt.plot(x, y, label="f(x)", color='black')

    # Plotting the points
    plt.scatter(x_points[below], y_points[below], color='green', label='Points below f(x)') #points below the curve in green
    plt.scatter(x_points[above], y_points[above], color='red', label='Points above f(x)') #points above the curve in red

    # Setting up the plot limits and labels
    plt.xlim(a - 1, b + 1) #x axis limits
    plt.ylim(0, M) #y axis limits
    plt.xlabel("x")
    plt.ylabel("y")
    plt.title("Monte Carlo Integration Visualization")
    plt.legend() #legend (i.e. key)

    plt.show() #show plot

# Function to be integrated
def f(x): #the function that we want to see which points lie below its curve and which are above the curve
    return x**2 + 2

# Parameters for Monte Carlo Integration
a, b, M, N = 1, 2, 20, 1000 # a, b, Max y value (I.e. M), N points

# Plotting the Monte Carlo Integration Visualization Function
plot_monte_carlo(f, a, b, M, N)

#if its below the line we call it a success (the green points)

import numpy as np #for numerical operations
import matplotlib.pyplot as plt #to generate plots

# Function for Monte Carlo Integration Function
def monte_carlo_integrate(func, a, b, N, M):
    S = 0 #intializing a counter number of points under the curve
    for _ in range(N):
        x = a + (b - a) * np.random.random() #random x coordinate within interval [a,b]
        y = M * np.random.random() #random y coordinate within range [0,M]
        if y < func(x): #is the point (x,y) under the curve?
            S += 1 #increase counter if point is under the curve
    return M * (b - a) * (S / N) #estimated area under the curve

# Function to be integrated
def f(x):
    return x**2 + 2

# Parameters
a, b, M = 1, 2, 20 #Integration bounds [a, b] and the maximum y-value M.
iterations = np.logspace(1, 6, 100, dtype=int)  # Using logarithmically spaced iterations for smoother curve. #from 10^1 to 10^6
estimated_areas = [] # to intialize an empty list to store the estimated areas

# Calculate estimated areas for different numbers of iterations
for N in iterations:
    estimated_area = monte_carlo_integrate(f, a, b, N, M)
    estimated_areas.append(estimated_area) #add estimated area to the list

# Plotting convergence
plt.figure(figsize=(10, 6))
plt.plot(iterations, estimated_areas, color='blue')
plt.xscale('log') #using log for better visualization
plt.xlabel('Number of Iterations (log scale)')
plt.ylabel('Estimated Area')
plt.title('Convergence of Monte Carlo Integration')
plt.grid(True)
plt.show()




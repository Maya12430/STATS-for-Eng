# -*- coding: utf-8 -*-
"""Maya  24 Lab 3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wzwONsyBBn3Lstx2MSTR4JNfEgiphats
"""

import numpy as np #for numerical operations
import matplotlib.pyplot as plt #to create plots

"""# Normal Random Number Generator"""

#CDF PDF

x = np.linspace(-10,10,1000) #(start, stop, how many points in between those start and end bounds)
y = 2.71**(-x**2) #computing the values of y by plugging in x values to the function
plt.plot(x,y) #plotting x against y

"""$e^{-x^2}$"""

import numpy as np
import matplotlib.pyplot as plt

# the range of x values: from -3 to 3, with small steps for smoothness
x = np.linspace(-3, 3, 1000)

# y values using the function e^(-x^2)
y = np.exp(-x**2)

plt.plot(x, y) #plot x against y
plt.title('$e^{-x^2}$') #plot title
plt.xlabel('x') #labeling the x axis as 'x'
plt.ylabel('y') #labeling the y axis as 'y'
plt.show()

"""![alt text](https://wikimedia.org/api/rest_v1/media/math/render/svg/4abaca87a10ecfa77b5a205056523706fe6c9c3f)"""

# defining the normal probability density function (PDF)
def normal_pdf(x,mu,sigma):

  return (1/(np.sqrt(2*np.pi*sigma**2)))*np.exp((-(x-mu)**2)/(2*sigma**2)) #the formula for normal PDF

x = np.linspace(-6,6,1000) #x values between -6 to 6

mu = 0 #mean

sigma = 1 #standard deviation

pdf = normal_pdf(x,mu,sigma) #pdf for each x value

plt.plot(x,pdf,'.') #(x,pdf,)in blue
# plt.plot(x,y,'g.')

plt.plot(x,y,'g.') #(x,y,)in green

n=5
x[2:4] #slices the x array from index 2 to 3
np.sum(x[0:n]) #summation of first n elements in the array

def cumulative_sum(x): #to approxiamte PDF

  y = np.zeros(x.shape) #to store the cumulative sum

  for n in range(x.shape[0]):

    y[n] = np.sum(x[0:n]) #summing elements from start to nth element

  y = y / np.max(y) #normalizing the cumulative sum

  return y

z=np.array([1,2,3,4,5]) #example array

z

cumulative_sum(z)  #normalized cumulative sum of array z

cdf = cumulative_sum(pdf) #cumulative distribution function (CDF) for the PDF
cdf

"""## input is the x axis, output is y axis"""

plt.plot(x,cdf,'.'); #running cumulative sum

# d_cdf = cdf[1:] - cdf[0:-1] #Demo to show that the derivative of the cdf gives you back the pdf
# plt.plot(x[1:],d_cdf,'.');  #Not required for sampling

plt.plot(cdf,x,'.');

import numpy as np #for numerical operations
import matplotlib.pyplot as plt # for plots

# Define a function to find the index of the nearest value in an array
def find_nearest(array, value):

  idx = np.argmin(np.abs(array - value)) #index of the smallest difference

  return idx

z=np.array([11,2,32,63,4,3,5,67]) #example array

find_nearest(z,22.1) #find index of the nearest value to 22.1 in array z

find_nearest(cdf, 0.1) #find index of value in cdf nearest to 0.1

x[393] #the value in x at index 393

xr = np.random.random((10000,)) #10000 random values between 0 and 1

r=np.random.random() #single random value between 0 and 1

r

x[find_nearest(cdf,r)] #to find the value in x nearest to the random number r

w = np.zeros(xr.shape[0]) #an array with same shape as xr

#corresponding to positions in cdf nearest to values in xr
for i in range(xr.shape[0]):

  w[i] = x[find_nearest(cdf, xr[i])]

w.shape

plt.hist(w,50); #histogram of the array with 50 bins

num_bins = 50
n,bins,patches = plt.hist(w, num_bins, density=1)
y = ((1 / (np.sqrt(2 * np.pi) * sigma)) * np.exp(-0.5 * (1 / sigma * (bins - mu))**2)) #normal disribution curve
plt.plot(bins,y) #plotting the normal distrubtion curve





"""# Homework

# Birthday Paradox
"""

import random #to generate random numbers

def simulate_birthday_paradox(people, simulations):  #probability of people (in the same room) having the same birthday
    matches = 0 #initialize counter

    for i in range(simulations):
        birthdays = [random.randint(1, 365) for _ in range(people)] #generate a list of random birthdays for 'people' number of people
        # each birthday is a random day in the year, assuming 365 days in a year
        #check if there are duplicates
        if len(birthdays) != len(set(birthdays)):
            matches += 1
#the probability of finding at least one match in the given number of simulations
    probability = matches / simulations
    return probability

# Number of people in the room
people = 40

# Number of simulations
simulations = 10000

# Calculate the probability
probability = simulate_birthday_paradox(people, simulations)
probability



"""# Monty Hall"""

import random #to generate random numbers

def simulate_monty_hall_final(simulations):
    wins_switching = 0 #counter for wins when player switches doors
    wins_staying = 0  #counter for win when player stays with their initial choice

   #looping through number of simulations
    for _ in range(simulations):
        # Randomly assign the car (the prize) to a door (1, 2, or 3)
        car_door = random.randint(1, 3)
        # Player makes an initial choice
        player_choice = random.randint(1, 3)

        # Host opens a door, which is neither the player's choice nor the car door
        for host_choice in [1, 2, 3]:
            if host_choice != car_door and host_choice != player_choice:
                break

        # Find the remaining door for the player to switch to
        for switch_choice in [1, 2, 3]:
            if switch_choice != player_choice and switch_choice != host_choice:
                break

        # Count the number of wins for staying with the initial choice
        if player_choice == car_door:
            wins_staying += 1

        # Count the number of wins for switching to the other door
        if switch_choice == car_door:
            wins_switching += 1

    # Calculate the probabilities of winning by staying and switching
    probability_staying = wins_staying / simulations
    probability_switching = wins_switching / simulations

    return probability_staying, probability_switching
#number of simulations to run
simulations = 10000000
# Running the final version of the simulation
final_probability_staying, final_probability_switching = simulate_monty_hall_final(simulations)
final_probability_staying, final_probability_switching #print results



"""# Simple Craps"""

import random #to generate random numbers

def simulate_dice_game(simulations):
    wins = 0 #initializing a counter for number of wins

    for _ in range(simulations):
        # Roll two six-sided dice
        roll = random.randint(1, 6) + random.randint(1, 6)

        # Check for immediate win or loss
        if roll in [7, 11]: # a first roll of 7 or 11 is a win
            wins += 1
            continue #skip loop and continue to next simulation
        elif roll in [2, 3, 12]: #a first roll of 2, 3, or 12 is a loss, however it won't affect (be against) player in this simulation
            continue # skip loop and continue to next simulation

        # Save the initial roll in case the game hasn't been decided in the first roll
        initial_roll = roll

        # Re-roll phase
        while True:
            roll = random.randint(1, 6) + random.randint(1, 6)
            if roll == 7:  # Loss condition
                break
            elif roll == initial_roll:  # Win condition
                wins += 1
                break

    probability_of_winning = wins / simulations
    return probability_of_winning

# Number of simulations
simulations = 10000

# Calculate the probability of winning the game
probability_of_winning = simulate_dice_game(simulations)
probability_of_winning

"""# Collector's Card Paradox

"""

import random #to generate random numbers

def simulate_card_collectors_problem(n, simulations):
    total_card_packs_bought = 0 #counter for the total card packs bought in all simulations

    for _ in range(simulations):
        collected_characters = set() #to keep track of the unique characters collected
        card_packs_bought = 0 #counter for number of card packs that were bought in this current simulation

        # Buy card packs until all characters are collected
        while len(collected_characters) < n:
            new_card = random.randint(1, n)
            collected_characters.add(new_card)
            card_packs_bought += 1 #increment the count of card packs bought


        total_card_packs_bought += card_packs_bought

    # Calculate the average number of card packs needed
    average_card_packs_needed = total_card_packs_bought / simulations
    return average_card_packs_needed

n = 10 # Number of different characters
simulations=10000 #number of simulations to run

# Calculate the expected number of card packs
expected_card_packs = simulate_card_collectors_problem(n, simulations)
expected_card_packs #average number of card packs needed



import random  #to generate random numbers

def simulate_sock_drawer_problem(n, simulations):
    total_draws = 0 #counter for total number of draws in all simulations

    for _ in range(simulations):
        socks = {} #a dictionary to keep track of the number of each sock color drawn
        draws = 0 #counter for the number of draws in this simulation

        while True: #continew to draw until a pair of socks has been found
            # Randomly draw a sock
            sock_color = random.randint(1, n)
            draws += 1 #increment the number of draws

            # Update the count for this color
            if sock_color in socks:
                socks[sock_color] += 1
            else:
                socks[sock_color] = 1

            # Check for a pair
            if socks[sock_color] == 2:
                break #break/exit if a pair has been found

        total_draws += draws

    # Calculate the average number of draws needed
    average_draws_needed = total_draws / simulations
    return average_draws_needed

# Number of pairs of socks
n = 10

# Number of simulations
simulations = 10000

# Calculate the expected number of draws
expected_draws = simulate_sock_drawer_problem(n, simulations)
expected_draws #average number of draws needed to find a pair of socks
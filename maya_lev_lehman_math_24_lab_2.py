# -*- coding: utf-8 -*-
"""Maya Lev Lehman_Math_24_Lab_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mkeQIJf9bxoEdr_KHd5V5BZPDPwYY19R
"""

#importing these libraries for the code to run
import numpy as np #this is used for numerical operations
import matplotlib.pyplot as plt #this is used to plot graphs

#to create an array of numbers:
numbers= np.array([1,2,2,3,3,3,4,4,4,4])

#to plot a histogram:
plt.hist(numbers,100); #(data,number of bins)

"""# PRNG"""

#to plot the sequance of values
x = 0.12345          # seed value
X = np.zeros(50000,)  # initialize an array of zeros

for i in range(X.shape[0]): #the size of the array
    x = 3*x % 1      # update x and store the value in X #uses modulus
    X[i] = x

plt.plot(X, '.')     # plot the values in X

#plotting histogram
plt.hist(X);

"""### Coin flip simulation"""

def coin():
    return 2*(np.random.random() > 0.5) - 1 #return -1 or 1 because a coin has only 2 sides

coin()

x = 0 #initalizing a number
x + coin() #adding that number to the result of the coin flip

x = 0 #setting x=0

for i in range(3): #flipping the coin 3 times and adding the result to x
    x = x + coin()

x #result based on previous step

x = 0 #setting x=0

for i in range(100): #flipping the coin 100 times and adding the result to x
    x = x + coin()

x #result based on previous step

M = 10000 # M is the number of experiments
N = 100 # N is the number of coin flips in each experiment M

X = np.zeros(M,) # storing the results for each experiment in X array of numbers

for j in range(M):

    x = 0

    for i in range(N):
        x = x + coin()

    X[j] = x

plt.hist(X,100);

#very unlikely to get 30 tails in a row or 30 heads in a row

"""# Bonus: Explain Pascal's Triangle"""

import numpy as np #importing Numpy for numerical operations

P = np.zeros((12,18)) #creating a matrix of 12 rows 18 coloumns (with zeros)

#setting a specific element of the matrix to 1
P[0,5]=1 #[1st row, 6th column]=1

#creating a loop over the rows and columns to populate the matrix
for i in range(1,P.shape[0]): #iteration over rows

    for j in range(1,P.shape[1]-1):  #iteration of coloumns (up to the second to last column)

        P[i,j] = P[i-1,j-1]+P[i-1,j] #every element is the sum of the element (directly) above it and of the element to the upper left

print(P[:,5:]) #printing the matrix from (,6 coloumn i.e the index 5) to the last column for all rows

"""# Normal Distribution"""

# Define the parameters for the normal distribution
mean = 0  # Mean (mu) of the distribution, set to equal 0
std_dev = 0.1  # Standard deviation (sigma) of the distribution, set to equal 0.1

# Generate 1000 data points following a normal distribution with the specified mean and standard deviation
sample_size = 1000 #number of data points to genrate (in this case it is 1000 data points)
data_points = np.random.normal(mean, std_dev, sample_size) #generating random data points (it is based on the normal disribution)

# Plot the histogram of the data points
bins_number = 30  # Number of bins for the histogram, set to equal 30
# Create the histogram
hist_count, x, ignored = plt.hist(data_points, bins_number, density=True) #density=true forms a probabilty density

# Plot the probability density function of the normal distribution
# Calculate the probabilty density function for each x
normal_dist_curve = 1 / (std_dev * np.sqrt(2 * np.pi)) * np.exp(- (x - mean) ** 2 / (2 * std_dev ** 2))
plt.plot(x, normal_dist_curve, linewidth=2, color='r') #'color r'= color red

# Set the title and labels for the plot
plt.title('Normal Distribution Visualization')
plt.xlabel('Value')
plt.ylabel('Probability Density')

# Display the plot
plt.show() #shows the probabilty density function and the historgram altogehter

#numpy array
x = np.array([1,2,3,4])

#sum of elements in the array
np.sum(x) # 1+2+3+4=10

#number of elements in the array
x.shape[0]

#calculating the average value (mean value) of the array
np.sum(x)/x.shape[0] # 10/2 = 2.5

#defining a function to calculate the mean
def mean(x):
    return np.sum(x)/x.shape[0] #the mean of the array

mean(x) #calculating mean using the defined function for it (using the step above)

x

#to subtract the mean from each element x
x - mean(x) #this will give us a 'centered' array

(x - mean(x))**2 #to sqaure each element of the centered array

# defining a function to calculate the variance
def var(x):
  return mean((x - mean(x))**2)

# defining a function to calculate the standard deviation
def std(x):
    return np.sqrt(var(x)) #returns squareroot of the variance (i.e. returns the standard deviation)

mean(x) #mean of x

var(x) #variance of x

std(x) #standard deviation of x



"""### Uniform Random Numbers"""

# Numpy for numerical operations, Matplotlib.pyplot for plotting
import numpy as np
import matplotlib.pyplot as plt
# Array of 50000 random numbers (between 0.0 and 1.0)
X = np.random.random(50000,)

X #the array of random numbers from 0.0 to 1.0 (i.e step above)

#plot the histogram of the random numbers
plt.hist(X,100); # X is data, 100 is the number of bins

#to generate one random number between 0.0 and 1.0
np.random.random()

#to store one random number r in between 0.0 and 1.0
r = np.random.random()

r #print r

#to generate a random integer between 1 and 9
r = np.random.randint(1,10)

r #print the random integer between 1 and 9

#to generate a same from the standard normal distribution
np.random.randn() # (mean 0, variance 1)

# to generate an array of samples from the standard normal distribution
numbers  = np.random.randn(2,4) #2x4 array

# shape of the array
numbers.shape

# reshape to one dimensional array
numbers = numbers.reshape(-1)

# the new shape of the array
numbers.shape

# numpy array
numbers= np.array([1,2,2,3,3,3,4,4,4,4])

# to plot the histogram of the array with 100 bins
plt.hist(numbers,100);

# to get a large array of samples (from the standard normal distribution)
numbers = np.random.randn(100000,)
plt.hist(numbers,100); #the histogram of the array of samples, with 100 bins

# to create a large array of numbers [0.0 , 1.0)
numbers = np.random.rand(1000000,)
plt.hist(numbers,100); #the histogram of the array, with 100 bins

#to set a seed for random number generator
np.random.seed(12345)
data = np.random.randn(2, 100) # 2x100 array (from standard normal distribution)

# to plot a figure to plot multiple subplots
plt.figure(1, figsize=(9, 9))

### creating 4 subplots:
plt.subplot(2,2,1) #first subplot 2x2 grid
plt.hist(data[0]) # histogram of first row of data

plt.subplot(2,2,2) #second subplot 2x2 grid
plt.scatter(data[0], data[1]) # scatter plot of first vs second row of data

plt.subplot(2,2,3) #third subplot 2x2 grid
plt.plot(data[0], data[1],'-') #line plot of first vs second row of data

plt.subplot(2,2,4) #fourth subplot 2x2 grid
plt.hist2d(data[0], data[1]) #2D histogram of first vs second row of data

plt.show() #the figure with all four subplots

"""Normal Dist Data"""

x = 10*np.random.randn(10000) #10000 samples from a normal distribution (mean is 0 standard deviation is 10)

plt.hist(x);

x = np.random.rand(1000,) #1000 samples from a uniform distribution between 0 and 1

plt.hist(x);



#parameters for normal distribution
mu = 10  # mean of distribution
sigma = 15  # standard deviation of distribution
x = mu + sigma * np.random.randn(10000)

# to plot the histogram of the normal distribution data
n,bins,patches = plt.hist(x,bins=100)

bins

# normal distribution curve
y = ((1 / (np.sqrt(2 * np.pi) * sigma)) * np.exp(-0.5 * (1 / sigma * (bins - mu))**2))
plt.plot(y)

#plotting the histogram with the normal distibution curve (i.e. y)
num_bins = 50
n,bins,patches = plt.hist(x, num_bins, density=1)
y = ((1 / (np.sqrt(2 * np.pi) * sigma)) * np.exp(-0.5 * (1 / sigma * (bins - mu))**2))
plt.plot(bins,y)



x #array x

### functions for statistical measures
def mean(x):
    return np.sum(x)/x.shape[0] #the mean of the array

def var(x):
    return mean((x - mean(x))**2) #the variance of the array

def std(x):
    return np.sqrt(var(x)) #the standrad deviation of the array

def median(x):
    n = len(x)
    sorted_x = np.sort(x) #sort array
    mid = n // 2 # to find middle index
    if n % 2 == 0: # calculates the median based on whether the length of x is even or odd
        return (sorted_x[mid - 1] + sorted_x[mid]) / 2
    else:
        return sorted_x[mid]

def mode(x):
    values, counts = np.unique(x, return_counts=True) #unique values and their counts
    max_count_index = np.argmax(counts) #index of the most freq value
    return values[max_count_index]

def range(x):
    return np.max(x) - np.min(x) #range of the array

#numpy array for the statistical functions
data = np.array([1, 2, 2, 3, 4, 5, 5, 5, 6])

# Testing the functions
mean_value = mean(data)
var_value = var(data)
std_value = std(data)
median_value = median(data)
mode_value = mode(data)
range_value = range(data)

#Displaying results of the statistical measures
mean_value, var_value, std_value, median_value, mode_value, range_value



"""# Homework



"""



"""# Pi from Random Numbers"""

import numpy as np
import matplotlib.pyplot as plt
N = 10000 # N random points to generate

#random points with coordinates between -1 and 1
points = -1 + 2*np.random.random((N,2)) #array (N,2) of random numbers

plt.plot(points[:,0],points[:,1],'.') #[:,0] x coordinates, [:,1] y coordinates

plt.gca().set_aspect(1) #aspect ratio is set to 1

#which points are inside the circle with radius 1
inside_circle  = points[:,0]**2 + points[:,1]**2  <=  1 #sum of coordinates
#which points are outside the circle
outside_circle = points[:,0]**2 + points[:,1]**2  > 1 #sum of coordinates

plt.plot(points[inside_circle,0],points[inside_circle,1],'g.') #plot inside the circle points in green
plt.plot(points[outside_circle,0],points[outside_circle,1],'r.') #plot outside the circle points in red


plt.gca().set_aspect(1)

# to count the number of points inside and the number of points outside the circle
np.sum(inside_circle),np.sum(outside_circle)

#the area of the square
total_area = 4

# to calculate the fraction of points inside the circle
fraction_inside = np.sum(inside_circle)/N

#approximation of pi
fraction_inside*total_area #estimation of area of the circle using the fraction of points in it

#to better the approximation of pi
N = 100000000 #increase the number of points to improve the estimation
points = -1 + 2*np.random.random((N,2))
inside_circle  = points[:,0]**2 + points[:,1]**2  <=  1
fraction_inside = np.sum(inside_circle)/N
fraction_inside*4

"""# Complete Code for Estimating π using Monte Carlo Simulation"""

# Number of random points to generate
num_points = 10000

# Generating random points
x_points = np.random.uniform(-1, 1, num_points) #uniformly distributed x coordinates
y_points = np.random.uniform(-1, 1, num_points) #uniformly distributed y coordinates

# Calculating the number of points inside the quarter circle
points_inside = np.sqrt(x_points**2 + y_points**2) <= 1 #checking if the distance of each point from origin is less than or equal to 1
num_inside = np.sum(points_inside) # to count the number of points inside the circle

# Estimating π
pi_estimate = 4 * num_inside / num_points #multiplying ratio by 4 to get an estimate of pi

# Plotting the points and the quarter circle
plt.figure(figsize=(6, 6))
plt.scatter(x_points[points_inside], y_points[points_inside], color='green', label='Inside')
plt.scatter(x_points[~points_inside], y_points[~points_inside], color='red', label='Outside')
circle = plt.Circle((0, 0), 1, color='blue', fill=False) #circle with radius 1
plt.gca().add_artist(circle)
plt.title('Estimating π using Monte Carlo Simulation')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.axis('equal')
plt.show()

pi_estimate #output for estimated pi value

"""# e from Random Numbers"""

import numpy as np

# 2D array of random numbers
X = np.random.random((1000000,10)) #1000000x10 array of numbers between 0 to 1

X

#cumulative sum
Y = np.cumsum(X,1)

Y

#finding first time in every row, when cumulative sum exceeds 1
Z = np.argmax(Y > 1,1) + 1 #np.argmax returns the indices of the first occurrence where 'Y > 1' is True
                             # adding 1 because indices in Python are 0-based

Z

np.mean(Z) # average count of random numbers needed for their cumulative sum to exceed 1

#repeating steps using a larger data set
np.mean(np.argmax(np.cumsum(np.random.random((10000000,10)),1) > 1,1) + 1)

np.exp(1) #value of e (estimated)





"""# Further Reading:

### Quantum Random Numbers API

https://aws.amazon.com/marketplace/pp/prodview-246kyrfjo3bag
"""



